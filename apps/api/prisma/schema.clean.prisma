// apps/api/prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL") // vem do apps/api/.env
}

enum Role {
  ADMIN
  ATTENDANT
  OWNER
}




model Tenant {
  id          String     @id @default(cuid())
  name        String     @unique
  cnpj        String?    @unique
  isActive    Boolean    @default(true)
  users       User[]
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  Session     Session[]
  cpfResLoja  String?    @unique
  email       String     @unique
  Supplier    Supplier[]
  Product     Product[]
  ownerUserId String?    @unique
  ownerUser   User?      @relation("TenantOwner", fields: [ownerUserId], references: [id])

  categories Category[] // FIX: back-relation obrigatório da relação Category.tenant

  @@index([isActive, createdAt])
}

model User {
  id                  String    @id @default(cuid())
  name                String?
  cpf                 String?   @unique
  tenantId            String
  tenant              Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  email               String
  passwordHash        String
  role                Role      @default(ATTENDANT)
  pinSupervisor       String?
  isActive            Boolean   @default(true)
  sessions            Session[]
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  mustChangePassword  Boolean   @default(false)
  passwordUpdatedAt   DateTime  @default(now())
  TenantOwner         Tenant?   @relation("TenantOwner")
  failedLoginCount    Int       @default(0)
  blockedUntil        DateTime?
  resetTokenHash      String?
  resetTokenExpiresAt DateTime?

  @@unique([tenantId, email])
  @@index([tenantId])
  @@index([isActive, role])
  @@index([blockedUntil])
}

model Session {
  id        String    @id @default(cuid())
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  revokedAt DateTime?
  jti       String?   @unique

  // multi-tenant por coluna
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  refreshHash String
  userAgent   String?
  ip          String?
  expiresAt   DateTime
  createdAt   DateTime @default(now())

  @@index([userId])
  @@index([tenantId])
  @@index([expiresAt])
}

model AuditLog {
  id        String   @id @default(cuid())
  tenantId  String
  userId    String?
  action    String
  entity    String
  entityId  String?
  diffJson  String?
  ip        String?
  device    String?
  hmac      String
  createdAt DateTime @default(now())

  @@index([tenantId, createdAt])
  @@index([entity, entityId])
}

model Supplier {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  name      String  @map("nome_fantasia")
  legalName String  @map("razao_social")
  cnpj      String  @map("cnpj") @db.VarChar(14)
  code      Int     @map("codigo_fornecedor")
  isActive  Boolean @default(true) @map("ativo")

  phone  String? @map("telefone") @db.VarChar(16)
  mobile String? @map("telefone_celular") @db.VarChar(16)
  email  String? @db.VarChar(120)

  ie           String? @db.VarChar(20)
  cep          String? @db.VarChar(8)
  city         String? @db.VarChar(60)
  uf           String? @db.VarChar(2)
  address      String? @db.VarChar(120)
  addressNo    String? @db.VarChar(10)
  complement   String? @db.VarChar(60)
  neighborhood String? @db.VarChar(60)

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  Product   Product[]

  @@unique([tenantId, cnpj], name: "supplier_cnpj_per_tenant")
  @@unique([tenantId, code], name: "supplier_code_per_tenant")
  @@unique([id, tenantId], name: "supplier_id_tenant_unique") // OK: necessário p/ FK composta Product→Supplier
  @@index([tenantId, name])
  @@map("fornecedores")
}


// --------------------- BD CATEGORIAS PRODUTOS ---------------------

enum Unit {
  UN  // unidade
  CX  // caixa
  KG  // quilograma
  LT  // litro
  GR // grama 
  ML // mililitro
  PC // Pacote ou Peça
}


model Product {
  id          String   @id @default(cuid())
  tenantId    String
  categoryId  String?
  category    Category? @relation(fields: [categoryId], references: [id])
  name        String
  sku         String    @default("")
  minQuantity   Decimal?      @db.Decimal(14,3)
  barcode     String?
  unit        Unit      @default(UN)
  price       Decimal   @db.Decimal(10,2)
  cost        Decimal?  @db.Decimal(10,2)
  minStock    Decimal?  @db.Decimal(14,3)
  isActive    Boolean   @default(true)

  // Campos fiscais (preparação p/ fases futuras)
  ncm         String?
  cest        String?
  csosn       String?
  cfop        String?

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  inventories Inventory[]

  @@index([tenantId, name])
  @@index([tenantId, barcode])
  @@unique([tenantId, sku])         // SKU único por tenant
  @@unique([tenantId, barcode])     // se quiser permitir repetição, remova esta e mantenha apenas @@index
}


model Category {
  id        String   @id @default(cuid())
  tenantId  String
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId, name])
  @@unique([tenantId, name]) // evita duplicidade por tenant
}


model StockLocation {
  id        String   @id @default(cuid())
  tenantId  String
  name      String   // ex.: "Balcão", "Cozinha", "Depósito"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  inventories Inventory[]

  @@unique([tenantId, name]) // evita duplicidade por tenant
}


model Inventory {
  id            String        @id @default(cuid())
  tenantId      String
  productId     String
  locationId    String
  quantity      Decimal       @db.Decimal(14,3) @default(0)
  
  version       Int           @default(0) // para lock otimista
  updatedAt     DateTime      @updatedAt

  product       Product       @relation(fields: [productId], references: [id])
  location      StockLocation @relation(fields: [locationId], references: [id])

  @@unique([tenantId, productId, locationId])
  @@index([tenantId, locationId])
  @@index([tenantId, productId])
}

enum MovementType { IN OUT ADJUST CANCEL RETURN }

model StockMovement {
  id          String        @id @default(cuid())
  tenantId    String
  productId   String
  locationId  String
  type        MovementType
  quantity    Decimal       @db.Decimal(14,3) // IN(+), OUT(-), ADJUST(+/-)
  reason      String?
  refId       String?       // id da venda/compra/ajuste
  diffJson    String?
  createdBy   String?       // userId
  createdAt   DateTime      @default(now())

  product     Product       @relation(fields: [productId], references: [id])
  location    StockLocation @relation(fields: [locationId], references: [id])

  @@index([tenantId, productId, createdAt])
  @@index([tenantId, locationId, createdAt])
}


model Purchase {
  id          String      @id @default(cuid())
  tenantId    String
  supplier    String?
  invoiceNo   String?
  total       Decimal?    @db.Decimal(12,2)
  createdBy   String?
  createdAt   DateTime    @default(now())
  items       PurchaseItem[]
}


model PurchaseItem {
  id          String   @id @default(cuid())
  tenantId    String
  purchaseId  String
  productId   String
  locationId  String
  quantity    Decimal  @db.Decimal(14,3)
  cost        Decimal? @db.Decimal(10,2)

  purchase    Purchase @relation(fields: [purchaseId], references: [id])
  product     Product  @relation(fields: [productId], references: [id])
  location    StockLocation @relation(fields: [locationId], references: [id])

  @@index([tenantId, productId])
}



